bool ray_intersect(vec3 orig, vec3 dir, inout float d, inout vec3 n, vec3 pos, float radius) {
  vec3 L = (pos - orig);
  float tca = dot(L , dir);
  float d2 = dot(L , L) - tca * tca;
  if (d2 > radius * radius) return false;
  float tcc = sqrt(radius * radius - d2);  // bottom len of triangle
  d = tca - tcc;
  float t1 = tca + tcc;
  if (d < 0.0) {
    d = t1;
  }
  if (d < 0.0) return false;

  n = normalize(dir * d + orig - pos);
  return true;
}

void main() {
  ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);
  ivec2 screen_size = imageSize(colorbuffer);
  if (pixel_pos.x >= screen_size.x || pixel_pos.y >= screen_size.y) {
    return;
  }

  // Build the Camera Ray
  float fov = radians(50.0);
  float x = (2.0 * (pixel_pos.x + 0.5) / screen_size.x - 1.0) * tan(fov / 2.0);
  float y = (2.0 * (pixel_pos.y + 0.5) / screen_size.y - 1.0) * tan(fov / 2.0) * screen_size.y / screen_size.x;
  vec3 ray_dir = normalize(vec3(x, y, -1));

  // Scene
  vec3  sphere_pos      = vec3(0, 1, 0);
  float sphere_radius   = 0.25;
  vec3  sphere_diff     = vec3(8, 27, 28) * 2.0 / 255.0;
  vec3  light_pos       = vec3(1, -1, 1);
  float light_intensity = 1;
  vec3  bg_color        = vec3(24, 39, 39) / 255.0;

  sphere_pos.x = sin(iTime) * 0.2;

  // Render
  sphere_pos = view_transform(sphere_pos);
  light_pos = view_transform(light_pos);

  float d;
  vec3 n;
  vec3 color;

  if (ray_intersect(vec3(0), ray_dir, d, n, sphere_pos, sphere_radius)) {
    vec3 hit = ray_dir * d;
    vec3 dir_light = normalize(light_pos - hit);
    float diff = clamp(dot(dir_light, n) * light_intensity, 0.0, 1.0);
    color = sphere_diff * diff;
  } else {
    color = bg_color;
  }

  imageStore(colorbuffer, pixel_pos, vec4(color, 1));
}
