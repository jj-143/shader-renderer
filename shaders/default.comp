bool ray_intersect(vec3 orig, vec3 dir, inout float d, inout vec3 n, vec3 pos, float radius) {
  vec3 L = (pos - orig);
  float tca = dot(L , dir);
  float d2 = dot(L , L) - tca * tca;
  if (d2 > radius * radius) return false;
  float tcc = sqrt(radius * radius - d2);  // bottom len of triangle
  d = tca - tcc;
  float t1 = tca + tcc;
  if (d < 0.0) {
    d = t1;
  }
  if (d < 0.0) return false;

  n = normalize(dir * d + orig - pos);
  return true;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  // Build the Camera Ray
  float fov = radians(50.0);
  float x = (2.0 * (fragCoord.x + 0.5) / iResolution.x - 1.0) * tan(fov / 2.0);
  float y = (2.0 * (fragCoord.y + 0.5) / iResolution.y - 1.0) * tan(fov / 2.0) * iResolution.y / iResolution.x;
  vec3 ray_dir = normalize(vec3(x, y, -1));

  // Scene
  vec3  sphere_pos      = vec3(0, 1, 0);
  float sphere_radius   = 0.25;
  vec3  sphere_diff     = vec3(8, 27, 28) * 2.0 / 255.0;
  vec3  light_pos       = vec3(1, -1, 1);
  float light_intensity = 1;
  vec3  bg_color        = vec3(24, 39, 39) / 255.0;

  sphere_pos.x = sin(iTime) * 0.2;

  // Render
  sphere_pos = view_transform(sphere_pos);
  light_pos = view_transform(light_pos);

  float d;
  vec3 n;
  vec3 color;

  if (ray_intersect(vec3(0), ray_dir, d, n, sphere_pos, sphere_radius)) {
    vec3 hit = ray_dir * d;
    vec3 dir_light = normalize(light_pos - hit);
    float diff = clamp(dot(dir_light, n) * light_intensity, 0.0, 1.0);
    color = sphere_diff * diff;
  } else {
    color = bg_color;
  }

  fragColor = vec4(color, 1);
}
